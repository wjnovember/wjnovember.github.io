<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>程序员叨叨叨</title>
    <link>http://wjnovember.github.io/</link>
    <atom:link href="/rss2.html" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 07 Nov 2021 09:47:15 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>《Unity Shader入门精要》笔记（一）</title>
      <link>http://wjnovember.github.io/UnityShadersBook01/</link>
      <guid>http://wjnovember.github.io/UnityShadersBook01/</guid>
      <pubDate>Sun, 07 Nov 2021 08:29:58 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;渲染流水线&quot;&gt;&lt;a href=&quot;#渲染流水线&quot; class=&quot;headerlink&quot; title=&quot;渲染流水线&quot;&gt;&lt;/a&gt;渲染流水线&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;渲染流水线&lt;/strong&gt;的工作任务是：将三维场景里的物体投到屏幕上，生成一张二维图像。&lt;br&gt;可
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h1><p><strong>渲染流水线</strong>的工作任务是：将三维场景里的物体投到屏幕上，生成一张二维图像。<br>可分为三个阶段：<strong>应用阶段</strong>、<strong>几何阶段</strong>、<strong>光栅化阶段</strong>。</p><p><img src="/UnityShadersBook01/img_01.png" alt></p><ul><li><p><strong>应用阶段</strong><br>CPU负责的阶段，应用主导，开发者有绝对的控制权，主要有三个任务：</p><ul><li>准备好场景数据</li><li>不可见物体剔除，提高渲染性能</li><li>设置好每个模型的渲染状态，如：材质、纹理、Shader等</li></ul><p>该阶段最重要的输出是<strong>渲染图元</strong>，如：点、线、三角面等，会被传递到下一个有GPU负责的阶段——几何阶段。</p></li><li><p><strong>几何阶段</strong><br>GPU负责的阶段，与每个渲染图元打交道，将三维空间的顶点数据转换到屏幕空间中，再将转换后的数据交给下一个阶段——光栅化阶段处理。关键词：<strong>逐顶点</strong>。</p></li><li><p><strong>光栅化阶段</strong><br>GPU负责的阶段，从上一阶段接过图元在屏幕空间的数据，差值计算后，决定图元里哪些像素会被绘制到屏幕中、被绘制成什么颜色。关键词：<strong>逐像素</strong>。</p></li></ul><h1 id="CPU和GPU之间的通信"><a href="#CPU和GPU之间的通信" class="headerlink" title="CPU和GPU之间的通信"></a>CPU和GPU之间的通信</h1><p>应用阶段的三个阶段：</p><ul><li><strong>把数据加载到显存</strong><br>数据加载到显存后，RAM的数据就可以移除了。但从硬盘加载到RAM过程十分耗时，CPU依然要访问数据，所以有些RAM中的数据不会马上移除。</li></ul><p><img src="/UnityShadersBook01/img_02.png" alt></p><ul><li><strong>设置渲染状态</strong><br>这些状态定义了场景中的网格是怎么被渲染的。</li></ul><p><img src="/UnityShadersBook01/img_03.png" alt></p><ul><li><strong>调用Draw Call</strong><br>Draw Call就是CPU发起命令，告诉GPU去执行一个渲染过程。一次DC（Draw Call）会指向本次调用需要渲染的图源列表。</li></ul><h1 id="GPU流水线"><a href="#GPU流水线" class="headerlink" title="GPU流水线"></a>GPU流水线</h1><p>GPU从CPU那里拿到顶点数据后，经过<strong>几何阶段</strong>和<strong>光栅化阶段</strong>将场景里的物体绘制到屏幕中。</p><p><img src="/UnityShadersBook01/img_04.png" alt></p><ul><li><strong>几何阶段</strong><ul><li>顶点着色器<br>完全可编程，实现顶点的空间变换、顶点着色等功能。</li><li>曲面细分着色器<br>可选的着色器，用于细分图元。</li><li>几何着色器<br>可选的着色器，执行逐图元的着色操作，或者生产更多的图元。</li><li>裁剪<br>将不存在摄像机视野内的顶点裁掉，并剔除某些三角图元的面片；也可以通过指令控制裁剪三角图元的正面或背面。</li><li>屏幕映射<br>不可配置、不可编程，负责把每个图元的坐标转换到屏幕坐标系中。</li></ul></li><li><strong>光栅化阶段</strong><ul><li>三角形设置<br>固定函数的阶段。</li><li>三角形遍历<br>固定函数的阶段。</li><li>片元着色器<br>完全可编程，实现逐片元的着色操作。</li><li>逐片元操作<br>不可编程，但可配置性很高，负责执行很多重要操作，如：修改颜色、深度缓冲、进行混合等。</li></ul></li></ul><p>我们需要重点关注的是<strong>顶点着色器（Vertex Shader）</strong>和<strong>片元着色器（Fragment Shader）</strong>。</p><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>顶点着色器需要完成工作主要有：<strong>坐标转换</strong>和<strong>逐顶点光照</strong>。</p><p><img src="/UnityShadersBook01/img_05.png" alt></p><p>坐标转换，将模型的顶点坐标从模型空间转换到其次裁剪空间。</p><p><img src="/UnityShadersBook01/img_06.png" alt></p><p>需要注意：<br>OpenGL中NDC的z分量范围是[-1, 1]<br>DirectX中NDC的z分量范围是[0, 1]</p><p>NDC，全称Normalized Device Coordinates，归一化的设备坐标。（后续会详细了解）</p><h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><p>一个图元和摄像机视野的关系有3种：</p><ul><li>完全在视野范围内<br>不裁剪，直接进入下一流水线阶段。</li><li>部分在视野范围内<br>进行裁剪后，进入下一流水线阶段。</li><li>完全在视野范围外<br>被剔除，不会进入下一流水线阶段。</li></ul><p><img src="/UnityShadersBook01/img_07.png" alt></p><h2 id="屏幕映射"><a href="#屏幕映射" class="headerlink" title="屏幕映射"></a>屏幕映射</h2><p>屏幕映射前，顶点的坐标仍然在三维坐标系下，屏幕映射的任务是将每个图元的x、y坐标转换到屏幕坐标系下。<br>屏幕坐标系和z坐标一起构成了<strong>窗口坐标系</strong>。</p><p>屏幕坐标系在OpenGL和DirectX之间的差异：</p><p><img src="/UnityShadersBook01/img_08.png" alt></p><h2 id="三角形设置"><a href="#三角形设置" class="headerlink" title="三角形设置"></a>三角形设置</h2><p>光栅化的第一个流水线阶段。<br>光栅化两个最重要的目标：</p><ul><li>计算每个图元（一般是三角形面片）覆盖了哪些像素</li><li>为这些像素计算颜色</li></ul><p>三角形设置是一个计算三角形网格表示数据的过程，提供三角形边界的表示方式，为下阶段三角形遍历做准备。</p><h2 id="三角形遍历"><a href="#三角形遍历" class="headerlink" title="三角形遍历"></a>三角形遍历</h2><p>遍历判断每个像素是否被一个三角网格覆盖，若覆盖，则生成一个<strong>片元（fragment）</strong>，这个过程也叫扫描变换。片元的信息数据通过三个顶点差值得到。</p><h2 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h2><p>DirectX中也被称为<strong>像素着色器（Pixel Shader）</strong>。<br>片元着色器的输入是顶点着色器的输出差值得到的结果，片元着色器的输出是一个或多个颜色值。</p><p><img src="/UnityShadersBook01/img_09.png" alt></p><h2 id="逐片元操作"><a href="#逐片元操作" class="headerlink" title="逐片元操作"></a>逐片元操作</h2><p>OpenGL里称为<strong>逐片元操作</strong>，DirectX中称为<strong>输出合并阶段</strong>。这个阶段有几个主要任务：</p><ul><li>决定每个片元可见性，涉及：深度测试、模板测试等。</li><li>通过测试后的片元与颜色缓冲区的颜色进行合并/混合。</li></ul><p><img src="/UnityShadersBook01/img_10.png" alt></p><p>深度测试、模板测试的简化流程图：</p><p><img src="/UnityShadersBook01/img_11.png" alt></p><ul><li><p><strong>模板测试</strong><br>高度可配置。<br>模板缓冲，和颜色缓冲、深度缓冲几乎是一类东西。即当前像素读取的参考值和模板缓冲中读取的参考值进行比较，满足条件则通过模板测试，条件规则由开发者指定。<br>不管模板测试有没有通过，我们都可以根据模板测试和深度测试的结果来修改模板缓冲区，操作修改可由开发者指定。</p></li><li><p><strong>深度测试</strong><br>高度可配置。<br>与模板测试类似，将当前片元的深度值和深度缓冲区的深度值进行比较，比较函数可由开发者设置，通常这个比较函数是小于等于的关系，也就是显示距离相机更近的物体。<br>如果深度测试没有通过，它没有权利更改深度缓冲区中的值；如果通过了，开发者可以指定是否用这个片元的深度值盖掉缓冲区中的深度值——通过开启/关闭深度写入来控制。</p></li></ul><p><img src="/UnityShadersBook01/img_12.png" alt></p><ul><li><strong>混合</strong><br>高度可配置。<br>开发者可选择开启/关闭混合模式，来控制是直接覆盖，还是将源颜色（当前片元的颜色）和目标颜色（颜色缓冲区的颜色）进行混合后写入颜色缓冲区。</li></ul><p>有些GPU为了提高性能，将深度测试放到片元着色器之前处理，这种技术称为<strong>Early-Z技术</strong>。</p><p>经过上述流程，颜色缓冲区中的颜色值被显示到屏幕上，但是为了防止正在进行光栅化的图元被显示在屏幕上，GPU采取了 <strong>双重缓冲（Double Buffering）</strong> 的策略，所以对场景的渲染是发生在幕后的，即： <strong>后置缓冲（Back Buffer）</strong> 中。</p><h1 id="什么是Shader"><a href="#什么是Shader" class="headerlink" title="什么是Shader"></a>什么是Shader</h1><p>Shader本质就是运行在GPU流水线上的可高度编程的代码，主要有：<strong>顶点着色器（Vertex Shader）</strong>、<strong>片元着色器（Fragment Shader）</strong>，今后的开发学习中也主要是和这两个着色器打交道。</p>]]></content:encoded>
      
      <comments>http://wjnovember.github.io/UnityShadersBook01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>从零开始设计游戏引导框架（二）</title>
      <link>http://wjnovember.github.io/GuideMgr02/</link>
      <guid>http://wjnovember.github.io/GuideMgr02/</guid>
      <pubDate>Sun, 19 Apr 2020 05:11:50 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h1&gt;&lt;p&gt;上文主要讲解了引导设计的一些理论概念，包括：引导分段、引导步骤、引导的触发、引导的操作以及引导的保存点。其中引导的触发分为触
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>上文主要讲解了引导设计的一些理论概念，包括：引导分段、引导步骤、引导的触发、引导的操作以及引导的保存点。其中引导的触发分为触发点和触发条件，此外还提到了引导的多条件判断；引导操作提到了操作的分类、操作定义和操作参数及扩展。本文将基于引导的理论概念，进行实操演练，主要包含配表和代码框架的初步编写。</p><h1 id="配表"><a href="#配表" class="headerlink" title="配表"></a>配表</h1><p>考虑到引导的触发和操作逻辑模块的不同，引导相关的表将分成两张，一张是引导的<strong>触发表</strong>，另一张是引导的<strong>步骤表</strong>。考虑到xlsx在合分支时的不便，这里使用csv格式进行配表。我们对上述两张表分别命名为：</p><ul><li>GuideTrigger.csv 引导触发表</li><li>GuideStep.csv 引导步骤表</li></ul><p>因为不同的团队会有自己的配表习惯，所以这里的配表格式仅以笔者的习惯为例，读者们主要了解配表分哪几列，每列配表的数据结构如何即可。</p><h2 id="步骤表"><a href="#步骤表" class="headerlink" title="步骤表"></a>步骤表</h2><img src="/GuideMgr02/img_guide_step_01.png"><p>上图是基于前一篇文章里提到的卡牌卡牌进阶引导进行了基本的配表操作，接下来对每一列的配置作详细说明。</p><h3 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h3><p>ID表示引导步骤的唯一标识，为数字类型，通常同一段引导里的步骤ID以连续的数字相连。上图中展示的是卡牌进阶引导的所有步骤，一共分为8步。</p><p>步骤表是要配置当前游戏所有的引导步骤的，那么不同分段的引导的步骤如何区分呢？</p><p>这里需要对ID的范围进行划分，笔者习惯以100作为一段引导的ID区间，如何理解呢？比如这里除了进阶引导外，还有一个卡牌重置引导，那么卡牌重置引导步骤的id范围可以规定在101~200之间，我们可以将这个引导的起始id设置为从101开始，配到表里面大概是这样的：</p><img src="/GuideMgr02/img_guide_step_02.png"><p>绿框里的内容表示卡牌进阶引导，红框里的内容表示卡牌重置引导。若后续还有其他引导，可以从201开始，以此类推。</p><h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>类别表示操作的分类，按照前文《理论篇》提到的分类方法，在类别这一列填写类别定义的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 操作类别定义</span><br><span class="line">1. 立绘对话</span><br><span class="line">2. 点击</span><br><span class="line">3. 拖动</span><br></pre></td></tr></table></figure><p>操作类别可根据需求自己定义。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>操作表示当前步骤具体做什么事，每一个具体的操作都需要做详细的定义，参考前文《理论篇》的定义，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0. 无操作</span><br><span class="line"></span><br><span class="line">// 点击操作定义</span><br><span class="line">201. 点击自己卡池里满足进阶条件的一张卡牌</span><br><span class="line">202. 点击卡牌详情界面的进阶按钮</span><br><span class="line">203. 点击进阶面板的进阶按钮</span><br><span class="line"></span><br><span class="line">// 拖动操作定义</span><br><span class="line">301. 在进阶面板拖动第1张材料卡到进阶消耗框</span><br></pre></td></tr></table></figure><p>定义后，将定义中操作内容对应的数字填写到表中“操作”一列中。操作的定义数字最好是类别定义的数字乘以100加X，这样方便知晓对应的操作属于哪一类别，方便抽象和扩展.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作 = 类别 * 100 + X</span><br></pre></td></tr></table></figure><h3 id="操作参数"><a href="#操作参数" class="headerlink" title="操作参数"></a>操作参数</h3><p>操作参数是对操作的补充，对做相同事情但操作对象有略微差别的一种说明。以卡牌进阶引导中，拖动卡池里的材料卡为例。假如卡牌进阶需要消耗两张卡池中的同名卡，这时候需要有两步引导操作，分别是：</p><ul><li>拖动卡池中第一张材料卡到待消耗区域</li><li>拖动卡池中第二张材料卡到待消耗区域</li></ul><p>这两步引导做的是相同的事情，但是拖动的卡牌略有不同，这时可以将“拖动卡池中的材料卡到待消耗区域”定义成一种操作，加上操作参数：第几张卡。</p><p>考虑到操作的补充参数可能不止一种，这里使用Json格式的字符串填写，方便扩展。</p><h3 id="对话内容"><a href="#对话内容" class="headerlink" title="对话内容"></a>对话内容</h3><p>对话内容只要用于立绘对话形式的引导步骤，直接填写对话文本即可，没有立绘对话的引导步骤可不填或填0表示内容为空。</p><h3 id="说话人物"><a href="#说话人物" class="headerlink" title="说话人物"></a>说话人物</h3><p>说话人物用于立绘对话形式的引导步骤，表示不同的说话人物。与操作定义类似，说话人物也需要定义，若说话人物使用的是本身游戏中的角色，可直接填写角色的id，填0表示无人物。</p><h3 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h3><p>保存点的必要性在前文《理论篇》已经提及，保存点的逻辑操作是，在当前步的操作已经做完，即将进入下一步前，往服务端发送一个引导ID，表示下一次重新登录时，引导从那一步ID开始。填0表示不往服务端发送保存点。</p><p>那为什么表里面会配置100？100这个引导ID并没有在表里出现呀？而且为什么引导走到了第7步还要往服务端发送引导ID为1的点呢？</p><p>其实这里的保存点不是引导ID，而是一个<strong>差值</strong>，填1表示将当前步的下一步引导ID发送给服务端保存，填2表示当前步骤的后面第2不的引导ID发送到服务端保存，而100则表示结束当前引导分段，并标记当前分段引导已完成，后续不再触发。</p><p>之所以填<strong>差值</strong>而不直接填<strong>引导ID</strong>的值，是因为引导的需求是在不断地变化的，很可能一段很长的引导，在前面步骤插入了一步，那么后续的引导ID都将往后+1，这样保存点也要跟着变动，保存点多的情况下很容易出现漏改的情况，因此使用<strong>差值</strong>可以减少变动。</p><p>一般情况下，引导保存点在当前步骤以后，所以默认引导保存点的值只有大于0的时候才有意义。</p><h2 id="触发表"><a href="#触发表" class="headerlink" title="触发表"></a>触发表</h2><img src="/GuideMgr02/img_guide_trigger_01.png"><p>上图是集成了卡牌进阶引导和卡牌重置引导的引导触发表，接下来对触发表的各列配置进行说明。</p><h3 id="ID-1"><a href="#ID-1" class="headerlink" title="ID"></a>ID</h3><p>引导触发表的ID，无实际意义，仅表示序列。</p><h3 id="分段ID"><a href="#分段ID" class="headerlink" title="分段ID"></a>分段ID</h3><p>分段ID是引导分段的唯一标识，结合步骤表的引导ID以100作为区间规则，我们默认：1~100的引导分段ID是0，101~200的分段ID是1，后续引导分段以此类推。</p><h3 id="触发点、触发点参数"><a href="#触发点、触发点参数" class="headerlink" title="触发点、触发点参数"></a>触发点、触发点参数</h3><p>触发点的概念在前文《理论篇》中已做详细讲解，这里补充一下触发点参数及定义。与操作参数类似，触发点参数是对触发点逻辑的补充，有了参数的补充，触发点可以做一些逻辑上的抽象，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 触发点及参数的定义</span><br><span class="line">1. 英雄等级达到N级时，判断引导触发条件</span><br><span class="line">参数：</span><br><span class="line">level：英雄等级</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">&#123;&apos;level&apos;:20&#125;</span><br><span class="line">当英雄升级到20级时，判断引导是否满足触发条件</span><br><span class="line"></span><br><span class="line">2. 当打开某个场景时，判断引导触发条件</span><br><span class="line">参数：</span><br><span class="line">scene：场景名字</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">&#123;&apos;scene&apos;:&apos;HeroesScene&apos;&#125;</span><br><span class="line">当进入卡池场景时，判断引导是否满足触发条件</span><br><span class="line"></span><br><span class="line">3. 卡牌重置功能解锁时，判断引导是否满足触发条件</span><br></pre></td></tr></table></figure><h3 id="触发条件、触发条件参数"><a href="#触发条件、触发条件参数" class="headerlink" title="触发条件、触发条件参数"></a>触发条件、触发条件参数</h3><p>触发条件的概念在前文《理论篇》中也做过讲解，这里也仅做补充说明。触发条件的填写与触发点类似，唯一不同的是：触发条件的配置是数组，需要支持多条件的填写，数字定义以<code>|</code>隔开，参数的填写也同理，多个Json字符串之间用<code>|</code>隔开，当不需要参数时，在参数列填0即可。多个触发条件之间是<strong>并</strong>的关系。定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 触发条件及参数的定义</span><br><span class="line">0. 无需条件，即可触发引导</span><br><span class="line"></span><br><span class="line">1. 当前在某个场景中</span><br><span class="line">参数：</span><br><span class="line">scene：场景名字</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">&#123;&apos;scene&apos;:&apos;HeroesScene&apos;&#125;</span><br><span class="line">引导满足当前场景在卡池界面时触发</span><br><span class="line"></span><br><span class="line">2. 卡池中有卡牌等级达到N级，且同名卡数量达到一定张数</span><br><span class="line">参数：</span><br><span class="line">level：卡牌等级</span><br><span class="line">num：同名卡数量</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">&#123;&apos;level&apos;:20,&apos;num&apos;:2&#125;</span><br><span class="line">当卡池中有卡牌等级达到20级，且同名卡数量至少有2张时，触发引导</span><br></pre></td></tr></table></figure><p>了解了触发表的各列含义，我们将其串联起来理解，便是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">卡牌进阶引导的触发（_groupId为0）：</span><br><span class="line">触发一：</span><br><span class="line">当有卡牌等级升到了20级时，判断当前场景在卡池界面，且有等级超过20级的卡牌有2张同名卡，触发引导。</span><br><span class="line">触发二：</span><br><span class="line">当进入卡池场景时，判断卡池中有卡牌等级达到20级且有至少2张同名卡，触发引导。</span><br><span class="line"></span><br><span class="line">卡牌重置引导的触发（_groupId为1）：</span><br><span class="line">触发一：</span><br><span class="line">当卡牌重置功能解锁时，即触发引导。</span><br></pre></td></tr></table></figure><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><blockquote><p>友情提示：请读者们将思维切换到编码思维。</p></blockquote><p>创建一个引导类，命名为GuideMgr.lua（Guide Manager）。</p><p>引导是分段触发的，所以需要有触发的判断和当前段引导的终止：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.checkTrigger</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.finish</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>引导分步骤，所以需要有当前步的开始和下一步：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.start</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.next</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>引导需要知晓当前在哪一步，以及记录哪些引导是已经走过的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GuideMgr._guideId</span><br><span class="line">GuideMgr._finished = &#123;&#125;</span><br></pre></td></tr></table></figure><p>这两个值一般在客户端收到登录包时，从服务器拿数据并解析得到。GuideMgr._finished的数据结构大概是这样的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GuideMgr._finished = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="literal">true</span>,</span><br><span class="line">    [<span class="number">3</span>] = <span class="literal">true</span>,</span><br><span class="line">    [<span class="number">11</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的1、3、11表示引导的分段ID，每当有新的引导完成时，该引导分段ID都将记录在这个结构里。</p><p>记录了引导ID以后，需要留一个接口，用来获取引导步骤表里面的对应步骤信息：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.getInfo</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>定义了上述几个方法后，就可以开始搭建引导的框架了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GuideMgr = class(<span class="string">"GuideMgr"</span>)</span><br><span class="line"></span><br><span class="line">GuideMgr._guideId = <span class="literal">nil</span></span><br><span class="line">GuideMgr._finished = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.checkTrigger</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.finish</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.start</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.next</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.getInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="触发判断"><a href="#触发判断" class="headerlink" title="触发判断"></a>触发判断</h2><p>先从触发的判断开始吧！触发的判断逻辑思维主要是传入对应的触发点，以及想要触发的引导分段id，然后在<code>GuideMgr.checkStart</code>方法里判断是否满足条件，若满足条件则调用<code>GuideMgr.start</code>方法开始分段引导的第一步。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.checkTrigger</span><span class="params">(point, group)</span></span></span><br><span class="line">    <span class="comment">-- No point, no trigger.</span></span><br><span class="line">    <span class="keyword">if</span> point == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Do not trigger a new guide when guiding.</span></span><br><span class="line">    <span class="keyword">if</span> GuideMgr.isGuiding() <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Init the candidate infos.</span></span><br><span class="line">    <span class="keyword">local</span> candidateInfos</span><br><span class="line">    <span class="keyword">if</span> group == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        candidateInfos = GuideMgr.getAllInfos()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span>(group) == <span class="string">"number"</span> <span class="keyword">or</span> <span class="built_in">type</span>(group) == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line">        candidateInfos = GuideMgr.getInfosByGroup(group)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> candidateInfos == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Filter infos by finished.</span></span><br><span class="line">    candidateInfos = GuideMgr.getUnfinishedInfos(candidateInfos)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Filter infos by trigger point.</span></span><br><span class="line">    candidateInfos = GuideMgr.getPointValidInfos(point, candidateInfos)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Filter infos by trigger condition.</span></span><br><span class="line">    candidateInfos = GuideMgr.getConditionValidInfos(candidateInfos)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Check candidate infos empty.</span></span><br><span class="line">    <span class="keyword">if</span> #candidateInfos == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Sort by priority and group id.</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">sort</span>(candidateInfos, <span class="function"><span class="keyword">function</span><span class="params">(ele1, ele2)</span></span></span><br><span class="line">        <span class="keyword">if</span> ele1._priority == ele2._priority <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> ele1._groupId &lt; ele2._groupId</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ele1._priority &gt; ele2._priority</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Start first guide step.</span></span><br><span class="line">    <span class="keyword">local</span> info = candidateInfos[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">local</span> triggerGroupId = info._groupId</span><br><span class="line">    <span class="keyword">local</span> guideId = triggerGroupId * <span class="number">100</span> + <span class="number">1</span></span><br><span class="line">    GuideMgr.start(guideId)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>GuideMgr.isGuiding</code>方法判断目前是否在引导中，通过GuideMgr._guideId是否大于0来区分，因为每走一步引导，GuideMgr._guideId都会被赋值，而这个值就是引导步骤表GuideStep.csv的<code>_id</code>一列的值。当引导结束时，GuideMgr._guideId会被赋值为0。代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.isGuiding</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> GuideMgr._guideId <span class="keyword">and</span> GuideMgr._guideId &gt; <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中<code>GuideMgr.getAllInfos</code>方法是从GuideTrigger.csv中获取每一行触发信息，以数组的形式返回。不同的项目组有不同的读表逻辑，这里就不贴出详细代码了。</p><p><code>GuideMgr.getInfosByGroup</code>方法是从GuideTrigger.csv中通过<code>_groupId</code>一列的值，筛选出指定引导分段的触发信息，以数组的形式返回。</p><p><code>GuideMgr.getUnfinishedInfos</code>方法是为了过滤掉已经触发过的引导，一般引导只会走一次，所以已经走过的引导不再触发。思路是从触发表中拿到<code>_groupId</code>的值，与GuideMgr._finished进行比对，若存在该值，则表示引导已经触发过。代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.getUnfinishedInfos</span><span class="params">(infos)</span></span></span><br><span class="line">    <span class="keyword">if</span> infos == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> ret = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, #infos <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> info = infos[i]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> GuideMgr.isFinished(info._groupId) <span class="keyword">then</span></span><br><span class="line">            ret[#ret + <span class="number">1</span>] = info</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.isFinished</span><span class="params">(groupId)</span></span></span><br><span class="line">    <span class="keyword">return</span> GuideMgr._finished[groupId] == <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>GuideMgr.getPointValidInfos</code>方法是在触发信息中筛选出相同<strong>触发点</strong>的信息，以数组形式返回。详细的触发点信息判断在<code>GuideMgr.isTriggerPointValid</code>方法中处理。传入的触发点变量可以是<code>number</code>类别，仅表示触发点；也可以是<code>table</code>类别，内包含触发点和触发点参数，结构如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    _point = GuideMgr.Point.enter_scene,</span><br><span class="line">    _param = &#123;</span><br><span class="line">        _sceneId = Data.SceneId.main_scene</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GuideMgr.getPointValidInfos</code>和<code>GuideMgr.isTriggerPointValid</code>详细代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.getPointValidInfos</span><span class="params">(point, infos)</span></span></span><br><span class="line">    <span class="keyword">local</span> ret = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, #infos <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> info = infos[i]</span><br><span class="line">        <span class="keyword">if</span> GuideMgr.isTriggerPointValid(info, point) <span class="keyword">then</span></span><br><span class="line">            ret[#ret + <span class="number">1</span>] = info</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.isTriggerPointValid</span><span class="params">(info, point)</span></span></span><br><span class="line">    <span class="keyword">local</span> param</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Parse param.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(point) == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line">        param = point._param</span><br><span class="line">        point = point._point</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Different trigger point.</span></span><br><span class="line">    <span class="keyword">if</span> info._point ~= point <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Special handling.</span></span><br><span class="line">    <span class="keyword">if</span> point == GuideMgr.Point.enter_scene <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- Compare with the info in GuideTrigger.csv.</span></span><br><span class="line">        <span class="keyword">local</span> sceneName = info._pointParam.scene</span><br><span class="line">        <span class="keyword">return</span> Data.SceneId[sceneName] == param._sceneId</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">-- More point param check.</span></span><br><span class="line">        <span class="comment">-- ...</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>筛选出满足触发点的触发信息后，继续通过<code>GuideMgr.getConditionValidInfos</code>方法筛选出<strong>触发条件</strong>满足的信息。详细判断逻辑在<code>GuideMgr.isConditionValid</code>方法中，通过传入<code>触发条件定义</code>和<code>触发条件参数</code>，具体逻辑具体判断。代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.getConditionValidInfos</span><span class="params">(infos)</span></span></span><br><span class="line">    <span class="keyword">local</span> ret = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, #infos <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> isValid = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">local</span> info = infos[i]</span><br><span class="line">        <span class="comment">-- Array already parsed.</span></span><br><span class="line">        <span class="keyword">local</span> conds = info._conds</span><br><span class="line">        <span class="comment">-- Parse param array.</span></span><br><span class="line">        <span class="keyword">local</span> params = <span class="built_in">string</span>.split(info._params, <span class="string">"|"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span>, #conds <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> GuideMgr.isConditionValid(conds[j], params[j]) <span class="keyword">then</span></span><br><span class="line">                isValid = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isValid <span class="keyword">then</span></span><br><span class="line">            ret[#ret + <span class="number">1</span>] = info</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.isConditionValid</span><span class="params">(condition, param)</span></span></span><br><span class="line">    <span class="keyword">if</span> condition == GuideMgr.Cond.current_scene <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- Get current scene.</span></span><br><span class="line">        <span class="keyword">local</span> scene = ...</span><br><span class="line">        <span class="keyword">return</span> Data.SceneId[param.scene] == scene._sceneId</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elseif</span> condition == GuideMgr.Cond.hero_by_num_level <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- Check condition validation.</span></span><br><span class="line">        <span class="comment">-- ...</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>过滤出满足触发点和触发条件的触发信息后，对信息按照优先级进行排序，排序后取第一条触发信息里的引导分段ID（_groupId），将分段ID转为当前分段引导的第一步引导ID，传入<code>GuideMgr.start</code>方法中开始当前分段的引导。</p><h2 id="开始引导"><a href="#开始引导" class="headerlink" title="开始引导"></a>开始引导</h2><p>触发判断筛选出符合要求的引导分段后开始引导，<code>GuideMgr.start</code>方法通过传入引导步骤ID，做当前步骤的引导操作，如：立绘说话、引导点击、其他引导效果等。<code>GuideMgr.starat</code>代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.start</span><span class="params">(guideId)</span></span></span><br><span class="line">    guideId = guideId <span class="keyword">or</span> M._guideId</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> guideId == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Check guide info validation.</span></span><br><span class="line">    <span class="keyword">local</span> info = GuideMgr.getInfo(guideId)</span><br><span class="line">    <span class="keyword">if</span> info == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- Guide info not exists.</span></span><br><span class="line">        GuideMgr.finish()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Set guide id.</span></span><br><span class="line">    GuideMgr._guideId = guideId</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Set view</span></span><br><span class="line">    GuideMgr.setView(info)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>GuideMgr.start</code>传入的参数——引导步骤ID（下称“引导ID”），当没有传参时，默认使用之前记录的引导ID。通过引导ID判断对应的引导步骤信息是否存在，若存在，将引导ID记录下来，并将对应的引导步骤信息传入视图层，做进一步的操作。</p><p><code>GuideMgr.getInfo</code>方法通过传入引导ID，从步骤表GuideStep.csv中读取对应<code>_id</code>的信息，若没有传参，则默认使用当前已记录的引导ID。代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.getInfo</span><span class="params">(guideId)</span></span></span><br><span class="line">    guideId = guideId <span class="keyword">or</span> M._guideId</span><br><span class="line">    <span class="keyword">if</span> guideId == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Get info in GuideStep.csv by _id.</span></span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="下一步引导"><a href="#下一步引导" class="headerlink" title="下一步引导"></a>下一步引导</h2><p><code>GuideMgr.next</code>是引导从当前步走向下一步的逻辑方法。</p><p>首先判断当前步骤的引导信息是否存在，不存在则结束当前引导，这个逻辑是一个容错，一般情况下不会存在：调用<code>GuideMgr.next</code>时，当前步骤信息不存在的情况。</p><p>然后判断当前步骤是否存在保存点，存在则将保存点对应的引导ID保存到服务端。</p><p>最后引导ID加1，传入<code>GuideMgr.start</code>方法中，开始下一步引导。</p><p>代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.next</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- Check current step info validation.</span></span><br><span class="line">    <span class="keyword">local</span> info = GuideMgr.getInfo()</span><br><span class="line">    <span class="keyword">if</span> info == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        GuideMgr.finish()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Check saving guide id.</span></span><br><span class="line">    GuideMgr.checkSave(info)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Next guide step id.</span></span><br><span class="line">    <span class="keyword">local</span> guideId = M._guideId + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> GuideMgr.start(guideId)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>保存点的逻辑是读取GuideStep.csv的<code>_saveId</code>一列，若对应的值大于0，则将该值加上当前步骤的ID（<code>_saveId</code>填的数值是相对值）所得的值，传入服务器进行保存。代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.checkSave</span><span class="params">(info)</span></span></span><br><span class="line">    <span class="keyword">if</span> info == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> saveId = info._saveId</span><br><span class="line">    <span class="keyword">if</span> saveId &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        saveId = info._id + saveId</span><br><span class="line">        <span class="comment">-- Save the id to the server.</span></span><br><span class="line">        GuideMgr.saveGuideId(saveId)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>GuideMgr.saveGuideId</code>方法做的逻辑是将传入的id发送到服务端进行保存。</p><h2 id="结束引导"><a href="#结束引导" class="headerlink" title="结束引导"></a>结束引导</h2><p>结束引导主要做重置数据、移除视图的操作，先看下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuideMgr.finish</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- Guide is not started.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> GuideMgr.isGuiding() <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">--[[ Reset data ]]</span><span class="comment">--</span></span><br><span class="line">    <span class="comment">-- Save guide group.</span></span><br><span class="line">    <span class="keyword">local</span> guideId = GuideMgr._guideId</span><br><span class="line">    <span class="keyword">local</span> groupId = <span class="built_in">math</span>.<span class="built_in">floor</span>(guideId / <span class="number">100</span>)</span><br><span class="line">    GuideMgr.saveGuideGroup(groupId)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Reset guide id.</span></span><br><span class="line">    GuideMgr.saveGuideId(<span class="number">0</span>)</span><br><span class="line">    GuideMgr._guideId = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">--[[ Remove view ]]</span><span class="comment">--</span></span><br><span class="line">    GuideMgr.removeView()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>GuideMgr.saveGuideGroup</code>往服务端保存一个引导分段ID，表示当前分段的引导已经完成，后面不再触发；实际的逻辑操作类似于把分段ID加到服务端的GuideMgr._finished结构里。</p><p><code>GuideMgr.removeView</code>做视图的移除操作，考虑到篇幅的限制，视图相关的逻辑将在下一篇文章中讲解。</p><h1 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h1><p>下一篇文章将继续本文的<strong>实操篇</strong>进行视图逻辑的讲解，主要包含：引导手指、高亮框、文本框的添加，点击、触摸限制逻辑的判断等，读者们看完下篇文章，基本可以自己写一个引导了。考虑到工作的原因，文章更新会比较慢，还请大家海涵！</p>]]></content:encoded>
      
      <comments>http://wjnovember.github.io/GuideMgr02/#disqus_thread</comments>
    </item>
    
    <item>
      <title>从零开始设计游戏引导框架（一）</title>
      <link>http://wjnovember.github.io/GuideMgr01/</link>
      <guid>http://wjnovember.github.io/GuideMgr01/</guid>
      <pubDate>Sat, 11 Apr 2020 12:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;背景叨叨叨&quot;&gt;&lt;a href=&quot;#背景叨叨叨&quot; class=&quot;headerlink&quot; title=&quot;背景叨叨叨&quot;&gt;&lt;/a&gt;背景叨叨叨&lt;/h1&gt;&lt;p&gt;大学毕业后入坑Cocos游戏开发已经快三年了，参与了两三个游戏的开发，经历过三四次颠覆式的版本迭代，其中涉足最深的莫
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="背景叨叨叨"><a href="#背景叨叨叨" class="headerlink" title="背景叨叨叨"></a>背景叨叨叨</h1><p>大学毕业后入坑Cocos游戏开发已经快三年了，参与了两三个游戏的开发，经历过三四次颠覆式的版本迭代，其中涉足最深的莫过于游戏引导框架的设计开发，一路走来踩过许多坑，感觉有必要写一个引导框架设计的系列博客，就叫《<strong>从零开始设计游戏引导框架</strong>》吧！文章基于Cocos-2dx平台，使用Lua脚本开发，涉及配表和代码编写，有不足之处，望读者们批评指正！</p><p>本文是系列文章的第一篇，先从理论层面开始梳理吧！</p><h1 id="引导的作用"><a href="#引导的作用" class="headerlink" title="引导的作用"></a>引导的作用</h1><p>假如一款全新的游戏上市，新的玩法、新的角色、新的场景摆在玩家面前，玩家一进入游戏而没有被告知玩法，一切的操作都需要玩家自己去摸索，那么这款游戏给人的感觉是“生硬”的，往往这一类游戏很难让玩家接受并耐着性子玩下去。</p><p>这时候如果给这个游戏加一个开场引导，交代游戏的背景，引导玩家按照核心玩法点击各个按钮，并告知每一步操作的作用，这样游戏会更能被玩家接受。</p><p>有时候，为了引起玩家的兴趣，开场引导中往往会加入更有代入感的剧情，加上华丽的美术特效，让玩家在玩游戏的过程中分泌更多的快乐素（多巴胺）。</p><p>至此，引导的作用就知晓了：</p><ul><li>增加代入感</li><li>交代核心玩法</li></ul><h1 id="引导是分段的"><a href="#引导是分段的" class="headerlink" title="引导是分段的"></a>引导是分段的</h1><p>然而游戏不仅只有开场引导，随着游戏进度的深入，玩家会接触越来越多的玩法操作，每个玩法都有其专属的引导。这时一个概念需要被树立：<strong>引导是分段的，一段引导对应一个玩法介绍。</strong></p><p>拿率土之滨举例子！</p><p>进入游戏后，玩家的主城被流寇抢夺，引导人物出来说几句话，然后引导玩家进行点击操作，这是<strong>游戏开场引导</strong>。</p><img src="/GuideMgr01/img_01.jpg" title="引导人物对话"><img src="/GuideMgr01/img_02.jpg" title="引导点击操作"><p>在一系列引导操作后，玩家可以自由操作了。这时玩家点击“演武”按钮进入了演武界面，一个新的引导——<strong>演武引导</strong>出现了，它会告诉玩家演武功能的基本操作。</p><img src="/GuideMgr01/img_03.jpg" title="演武引导"><p>从演武界面出来后，玩家进入招募界面，<strong>招募引导</strong>会告知玩家点指定卡包抽卡。</p><img src="/GuideMgr01/img_04.jpg" title="招募引导"><p>引导会根据需要，在玩家首次进入某个界面或满足条件时触发，以帮助玩家理解对应玩法。</p><p>每一个功能点都可以以一段引导辅助说明。</p><h1 id="每段引导分步骤"><a href="#每段引导分步骤" class="headerlink" title="每段引导分步骤"></a>每段引导分步骤</h1><p>上面说的<strong>引导分段</strong>只是从功能层面定义，而引导里具体做什么是需要程序员去定义拆分的，简言之，<strong>引导需要分步骤</strong>。</p><p>以率土的开场引导为例，玩家进入游戏:</p><ul><li>第1步，流寇部队进攻玩家主城；</li><li>第2步，流寇将领出现在屏幕上，说一句话；</li><li>第3步，引导主人公出现，说一句话；</li><li>第4步，引导玩家点击地图格……</li></ul><p>一段引导就是这样一步接一步进行的。当策划提出一个引导需求时，最多只会给出大致流程，至于如何将一段引导拆分成步骤，需要程序员自行梳理。</p><p>分步，是一种思维方式，如何合理拆分，让代码更容易维护，是一个日积月累的过程。</p><img src="/GuideMgr01/img_05.jpg"><h1 id="引导的触发"><a href="#引导的触发" class="headerlink" title="引导的触发"></a>引导的触发</h1><p>引导的触发，是针对一段引导而言，一段引导是交代<strong>做什么事情</strong>，而触发则是交代<strong>什么时候</strong>做事。</p><p>为了让读者们更容易理解，我们代入一个场景。</p><h2 id="场景代入"><a href="#场景代入" class="headerlink" title="场景代入"></a>场景代入</h2><p>假设在一个卡牌养成类游戏中，卡牌有等级，可以进阶（每进阶一级，黄色星星会有一颗变成红色），大概像这样：</p><img src="/GuideMgr01/img_card_01.png" title="蓝框框：等级，红框框：星级（阶）"><p>（蓝色框框：等级，红色框框：星级 或 “阶”）</p><p>接下来策划提出要做一个卡牌的进阶引导，已知进阶的条件是：</p><ul><li>英雄等级达到20级；</li><li>有其他同名卡牌作为进阶素材；</li></ul><blockquote><p><strong>同名卡牌</strong>：名字相同的卡牌。<br>比如我有两张吕蒙，可以把其中一张吕蒙作为另一张吕蒙进阶材料。</p></blockquote><h2 id="触发点-amp-触发条件"><a href="#触发点-amp-触发条件" class="headerlink" title="触发点 &amp; 触发条件"></a>触发点 &amp; 触发条件</h2><p>场景有了，接下来聊聊引导的触发。</p><p>如果说，引导是<strong>什么时候，该做什么事</strong>。<br>那么，引导的触发就是<strong>什么时候</strong>。</p><p>但是这个<strong>时候</strong>包含着两层含义：</p><ul><li>触发点</li><li>触发条件</li></ul><p>将它代入到之前场景里，就是：在卡牌等级经验达到20级的那个<strong>触发点</strong>，卡牌满足有同名卡的<strong>触发条件</strong>，触发卡牌进阶引导。</p><p>用英文的方式理解，就是：</p><ul><li>触发点 = <strong>when</strong></li><li>触发条件 = <strong>it is</strong></li></ul><p>两者连在一起，就是：<strong>When it is …, 触发引导</strong>。</p><h2 id="触发的多情况判断"><a href="#触发的多情况判断" class="headerlink" title="触发的多情况判断"></a>触发的多情况判断</h2><p>前面提到，当卡牌等级达到20级时，如果存在同名卡就触发引导。</p><p>那么如果吕蒙卡牌到达20级时，没有同名卡该怎么触发引导呢？</p><p>这个时候需要<strong>把引导的触发点和触发条件互换一下</strong>，也就是当玩家得到一张吕蒙时，如果吕蒙有同名卡且多张吕蒙卡牌中有至少一张卡牌等级达到20级，则引导触发。</p><p>简单写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">触发点：获得一张卡牌</span><br><span class="line">触发条件：</span><br><span class="line">1. 该卡牌存在同名卡</span><br><span class="line">2. 同名卡中至少存在一张等级达到20级的卡牌</span><br></pre></td></tr></table></figure><p>综上，一个引导的触发，需要多情况判断，在设计引导时，只有尽可能细化引导触发的各个因素，才能在后期的开发中尽可能减少BUG的出现。</p><h1 id="引导的操作"><a href="#引导的操作" class="headerlink" title="引导的操作"></a>引导的操作</h1><p>如果说引导的触发是针对引导分段，那么引导的操作则是针对引导分步，即：<strong>每一步做什么事</strong>。</p><h2 id="操作分类"><a href="#操作分类" class="headerlink" title="操作分类"></a>操作分类</h2><p>引导的操作很杂，根据策划的需求，会有不同的形式，比如：</p><ul><li>点击某个按钮</li><li>拖动某张卡牌</li><li>高亮某个区域</li><li>显示一个立绘对话</li><li>……</li></ul><p>根据操作形式的共性，将其抽象分类如下：</p><ul><li>点击</li><li>拖动</li><li>高亮框</li><li>对话</li></ul><p>定义了分类后，那么问题来了：为什么要将操作分类呢？</p><p>因为操作有其共性，有共性就意味着会有相同的代码逻辑，做好分类后方便对操作统一管理。</p><p>以<strong>点击</strong>举例子：</p><p>在强制引导点击时，我们知道，玩家只能点击指定的控件，而不能点击控件以外的地方。这时需要做的统一逻辑，就是：在手指点击屏幕的那一刻，判断手指点击的位置，判断是不是按钮区域。是，则不阻挡事件传递；否则，阻挡触摸事件。</p><p>然而操作的分类不仅仅局限于上述几类，分类可根据策划的需求做进一步扩展。在偏剧情向的引导中，可能还需增加“剧情”类别，若剧情是有固定形式的展现，还可根据实际情况做进一步分类，如：</p><ul><li>剧情：多格漫画</li><li>剧情：镜头拉伸</li><li>剧情：视频</li><li>……</li></ul><p>所以操作的分类是灵活多变的，具体分类根据需求来定。</p><h2 id="操作定义"><a href="#操作定义" class="headerlink" title="操作定义"></a>操作定义</h2><p>操作最终还需落实到具体细节，也就是<strong>具体做什么事</strong>。之前定义了“点击”类别，那么具体点击什么，就需要做具体的定义了。</p><p>以之前的“卡牌进阶引导”为例，当触发引导时，引导步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. NPC说话：“主公，您有一个英雄已经满足进阶条件了，我们现在来看看吧！”</span><br><span class="line">2. 引导点击满足进阶条件的卡牌，进入卡牌详情页</span><br><span class="line">3. 引导点击卡牌详情页的进阶按钮，进入卡牌进阶界面</span><br><span class="line">4. NPC说话：“现在请主公将材料卡拖动到消耗框里。”</span><br><span class="line">5. 引导从卡牌列表框中拖动一张同名卡到消耗框中</span><br><span class="line">6. 引导点击进阶按钮确认进阶</span><br><span class="line">7. NPC说话：“恭喜主公成功进阶武将！”</span><br></pre></td></tr></table></figure><img src="/GuideMgr01/img_upgrade_01.png"><p>根据上述操作步骤，对操作定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 操作类别定义</span><br><span class="line">1. 立绘对话</span><br><span class="line">2. 点击</span><br><span class="line">3. 拖动</span><br><span class="line"></span><br><span class="line">// 具体操作定义</span><br><span class="line">0. 无操作</span><br><span class="line"></span><br><span class="line">// 点击操作定义</span><br><span class="line">201. 点击自己卡池里满足进阶条件的一张卡牌</span><br><span class="line">202. 点击卡牌详情界面的进阶按钮</span><br><span class="line">203. 点击进阶面板的进阶按钮</span><br><span class="line"></span><br><span class="line">// 拖动操作定义</span><br><span class="line">301. 在进阶面板拖动第1张材料卡到进阶消耗框</span><br><span class="line"></span><br><span class="line">// 对话在流程表中填写具体对话内容和人物即可，无需定义</span><br><span class="line">// 说话人物定义</span><br><span class="line">0. 无人物</span><br><span class="line">1. NPC</span><br></pre></td></tr></table></figure><p>根据定义，配引导流程表如下（配表后面细讲，这里看个大概即可）：</p><table><thead><tr><th align="left">id</th><th align="left">类别</th><th align="left">操作</th><th align="left">对话内容</th><th align="left">说话人</th></tr></thead><tbody><tr><td align="left">_id</td><td align="left">_type</td><td align="left">_action</td><td align="left">_text</td><td align="left">_role</td></tr><tr><td align="left">H</td><td align="left">H</td><td align="left">H</td><td align="left">D</td><td align="left">H</td></tr><tr><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">主公，您有一个英雄已经满足进阶条件了，我们现在来看看吧！</td><td align="left">1</td></tr><tr><td align="left">2</td><td align="left">2</td><td align="left">201</td><td align="left"></td><td align="left">0</td></tr><tr><td align="left">3</td><td align="left">2</td><td align="left">202</td><td align="left"></td><td align="left">0</td></tr><tr><td align="left">4</td><td align="left">1</td><td align="left">0</td><td align="left">现在请主公将材料卡拖动到消耗框里。</td><td align="left">1</td></tr><tr><td align="left">5</td><td align="left">3</td><td align="left">301</td><td align="left"></td><td align="left">0</td></tr><tr><td align="left">6</td><td align="left">2</td><td align="left">203</td><td align="left"></td><td align="left">0</td></tr><tr><td align="left">7</td><td align="left">1</td><td align="left">0</td><td align="left">恭喜主公成功进阶武将！</td><td align="left">1</td></tr></tbody></table><h2 id="操作参数"><a href="#操作参数" class="headerlink" title="操作参数"></a>操作参数</h2><p>假如引导的需求是拖动两张材料卡进行进阶，那么做两次定义就显得冗余了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">！！！ 不推荐这样定义</span><br><span class="line">301. 在进阶面板拖动第1张材料卡到进阶消耗框</span><br><span class="line">302. 在进阶面板拖动第2张材料卡到进阶消耗框</span><br></pre></td></tr></table></figure><p>因此需要对操作定义进行扩展，给对应操作增加参数配置，原来301的定义就变成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 拖动操作定义</span><br><span class="line">301. 在进阶面板拖动第n张材料卡到进阶消耗框 n表示第几张</span><br></pre></td></tr></table></figure><p>相应的，引导流程表也需要多加一列：</p><table><thead><tr><th align="left">id</th><th align="left">类别</th><th align="left">操作</th><th align="left">操作参数</th><th align="left">对话内容</th><th align="left">说话人</th></tr></thead><tbody><tr><td align="left">_id</td><td align="left">_type</td><td align="left">_action</td><td align="left">_actParam</td><td align="left">_text</td><td align="left">_role</td></tr><tr><td align="left">H</td><td align="left">H</td><td align="left">H</td><td align="left">H</td><td align="left">D</td><td align="left">H</td></tr><tr><td align="left">5</td><td align="left">3</td><td align="left">301</td><td align="left">1</td><td align="left"></td><td align="left">0</td></tr><tr><td align="left">6</td><td align="left">3</td><td align="left">301</td><td align="left">2</td><td align="left"></td><td align="left">0</td></tr></tbody></table><p>上述配表，表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第5步，在进阶面板拖动第1张材料卡到进阶消耗框</span><br><span class="line">第6步，在进阶面板拖动第2张材料卡到进阶消耗框</span><br></pre></td></tr></table></figure><h2 id="操作参数扩展"><a href="#操作参数扩展" class="headerlink" title="操作参数扩展"></a>操作参数扩展</h2><p>在一些逻辑复杂的引导中，一个操作参数往往不能满足需求，这是将<code>_actParam</code>参数由配置数字改为配置<strong>Json格式的字符串</strong>，可支持多参数的配置。</p><p>举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 点击操作定义</span><br><span class="line">201. 点击自己卡池里满足进阶条件的一张卡牌</span><br><span class="line">参数：</span><br><span class="line">id：卡牌的id</span><br><span class="line">lv：卡牌的等级</span><br><span class="line">sameNum：同名卡数量</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">&#123;&apos;id&apos;:1,&apos;lv&apos;:20,&apos;sameNum&apos;:2&#125;</span><br><span class="line">点击卡池中id为1，等级至少为20，且同名卡数量超过2张的卡牌</span><br><span class="line"></span><br><span class="line">// 拖动操作定义</span><br><span class="line">301. 在进阶面板拖动第n张材料卡到进阶消耗框</span><br><span class="line">参数：</span><br><span class="line">index：表示第几张材料卡</span><br></pre></td></tr></table></figure><p>引导流程表就变成了这样：</p><table><thead><tr><th align="left">id</th><th align="left">类别</th><th align="left">操作</th><th align="left">操作参数</th><th align="left">对话内容</th><th align="left">说话人</th></tr></thead><tbody><tr><td align="left">_id</td><td align="left">_type</td><td align="left">_action</td><td align="left">_actParam</td><td align="left">_text</td><td align="left">_role</td></tr><tr><td align="left">H</td><td align="left">H</td><td align="left">H</td><td align="left">S</td><td align="left">D</td><td align="left">H</td></tr><tr><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">主公，您有一个英雄已经满足进阶条件了，我们现在来看看吧！</td><td align="left">1</td></tr><tr><td align="left">2</td><td align="left">2</td><td align="left">201</td><td align="left">{‘id’:10001,’lv’:20,’moreThan’:2}</td><td align="left"></td><td align="left">0</td></tr><tr><td align="left">3</td><td align="left">2</td><td align="left">202</td><td align="left">0</td><td align="left"></td><td align="left">0</td></tr><tr><td align="left">4</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">现在请主公将材料卡拖动到消耗框里。</td><td align="left">1</td></tr><tr><td align="left">5</td><td align="left">3</td><td align="left">301</td><td align="left">{‘index’:1}</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">6</td><td align="left">3</td><td align="left">301</td><td align="left">{‘index’:2}</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">7</td><td align="left">2</td><td align="left">203</td><td align="left">0</td><td align="left"></td><td align="left">0</td></tr><tr><td align="left">8</td><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">恭喜主公成功进阶武将！</td><td align="left">1</td></tr></tbody></table><p>至此，引导的操作，暂告一段落，若这一块读者们没有看懂，且先放放，后续会做详细讲解。</p><h1 id="引导的保存点"><a href="#引导的保存点" class="headerlink" title="引导的保存点"></a>引导的保存点</h1><p>在产品里，有这么一句话，叫“你永远不知道你的用户是怎么使用你的产品的”。</p><p>游戏也类似，永远不要指望玩家一口气把你写的那一段引导流畅的跑完。在引导过程中，玩家很可能经历：游戏BUG闪退、上课玩游戏被老师抓到等情况，一旦类似的情况发生，引导肯定会中途断掉，而如果玩家再重新上线，看到之前走过的漫长的引导又要重新走一遍时，有很大的概率，玩家是没有耐心继续玩下去的。</p><p>更何况，有些操作是不可重复的，比如玩家走引导，用系统送的货币抽卡，如果重新走一遍，很有可能第二次抽卡货币就不够了，这样的异常会导致引导卡死，这无疑会劝退一大波玩家。</p><p>因此，<strong>保存点</strong>这一概念加入到引导中，以<strong>抽卡引导</strong>为例：</p><p>在点击抽卡按钮的那一步操作里，将引导的保存点设置为下一步引导的id，这样下次重新登录后，引导就会从点抽卡按钮之后的那一步开始继续引导了。</p><p>这里先简单讲解下概念，后续实操篇会详细讲解。</p><h1 id="理论篇收尾"><a href="#理论篇收尾" class="headerlink" title="理论篇收尾"></a>理论篇收尾</h1><p>本文<strong>理论篇</strong>旨在为下一篇配表、编码做一个理论铺垫，防止直接讲解给读者们带来困惑。下一篇为本系列文章的<strong>实操篇</strong>，主要讲解基本的配表和初步的编码逻辑。考虑到工作因素，笔者写文章频率会较低，更新较慢，还请读者们海涵！</p>]]></content:encoded>
      
      <comments>http://wjnovember.github.io/GuideMgr01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>游戏闪念：饭途中的叨叨笔记（持续更新）</title>
      <link>http://wjnovember.github.io/game_thinking/</link>
      <guid>http://wjnovember.github.io/game_thinking/</guid>
      <pubDate>Mon, 30 Dec 2019 06:57:55 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;叨叨在前&quot;&gt;&lt;a href=&quot;#叨叨在前&quot; class=&quot;headerlink&quot; title=&quot;叨叨在前&quot;&gt;&lt;/a&gt;叨叨在前&lt;/h1&gt;&lt;p&gt;最近发现，笔者在和同事去吃饭的路上，会偶尔聊起各自对游戏的一些理解，其中不乏一些感觉“在理”的想法，于是笔者决定将这些想法写
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="叨叨在前"><a href="#叨叨在前" class="headerlink" title="叨叨在前"></a>叨叨在前</h1><p>最近发现，笔者在和同事去吃饭的路上，会偶尔聊起各自对游戏的一些理解，其中不乏一些感觉“在理”的想法，于是笔者决定将这些想法写成一篇博客，一者打磨一下自己锈钝的措辞，再者方便自己日后回顾。庸人庸笔，有不当之处，权当戏言。</p><h1 id="什么样的游戏可以吸引玩家持续玩下去呢？"><a href="#什么样的游戏可以吸引玩家持续玩下去呢？" class="headerlink" title="什么样的游戏可以吸引玩家持续玩下去呢？"></a>什么样的游戏可以吸引玩家持续玩下去呢？</h1><p>那时执迷于一款SLG手游《率土之滨》，核心玩法用几个关键字来形容，就是：<strong>培养武将</strong>、<strong>攻城略地</strong>。而笔者对这款游戏的依赖就如同呼吸需要氧气，早晨醒来第一件事就是摸起手机抽卡、打地，吃饭、蹲坑甚至走路都要打开看上几眼。不夸张的说，在这款游戏前，笔者玩游戏从来都是铁公鸡，舍不得花一分钱，而这款游戏让笔者开始充起了月卡。</p><p>为何它让笔者如此着迷，思前想后，笔者找到了一个原因：<strong>它让我感觉我拥有了有价值的东西</strong>。一赛季的时候，作为小白玩家，每每抽到五星，那迷人的紫色光效，让笔者感觉自己抽到了好东西（后来笔者发现，抽到的都是私聊卡-_-||）；而二赛季的时候，虽然只拿到了割据奖励，但是抽到了割据包里仅有的三张限定卡，让笔者感觉他们“可堪一用”，于是一直抱着期待，努力发育，只为看到他们在战场上一展英姿；而三赛季的时候，同样只拿到割据奖励的笔者，幸运地在赛季卡包里抽到了征服奖励也不容易抽到的弓·诸葛亮，这让笔者有了中彩票的飘飘然，于是愈加地珍惜自己的游戏账号。</p><p>说实话，笔者真不是玩游戏的料，玩各种游戏水平都很一般，甚至可以达到“菜”的水平，但是《率土之滨》成了笔者玩的时间最长的游戏之一，并且是持续地氪金，不是因为玩得多好，而是因为笔者觉得自己的账号“有价值”。在玩率土的几年时间里，笔者也玩了不少的小号，但是不久便回到老区玩大号了。假设当初没有抽到三张割据限定卡，没有抽到弓·诸葛亮，可能这个游戏早就从笔者的手机中删除了。</p><p>那么从开发和设计的角度，基于上述得到的结论便是：<strong>开局送给玩家“有价值”的东西</strong>，至少要看起来让玩家觉得这个东西有价值。这一点《万国觉醒》做得很讨巧，它并不是一进入游戏就送给玩家橙卡，而是在玩家体验了差不多半个小时到一个小时的某个时间节点，以抽卡比得橙卡的方式送给玩家。这样的做法筛选掉了一批对游戏核心玩法不感冒的玩家，留下（准）目标玩家，加以橙卡诱惑之，而接下来就是玩家抱着橙卡心甘情愿地入坑了。</p><h1 id="如何让氪金游戏看起来良心？"><a href="#如何让氪金游戏看起来良心？" class="headerlink" title="如何让氪金游戏看起来良心？"></a>如何让氪金游戏看起来良心？</h1><p>啊呸！氪金游戏哪有良心的，不都奔着钱去的嘛！确实如此，但是这里讲的是：如何让游戏的吃相不那么难看。</p><p>半年前的某天，听老板说《万国觉醒》手游出海表现非常好，因为与正在开发的SLG游戏属于同类别，于是下过来体验了一段时间，可以说核心玩法、创新、细节都有值得说道的地方，但是这里我们只谈“首充”。首充作为平民玩家向氪金玩家的过渡，精心设计，目测可以很大程度提高付费率。笔者之前见过其他游戏的首充，如：《率土之滨》的首充送何太后，《三国志·战略版》的首充送孙坚，两者首充送的将确实很应景，都是赛季初帮助新手顺利过渡的好东西，但是深入地玩下去，不难发现开局送的东西到后面基本被沦为材料卡。</p><p><img src="https://upload-images.jianshu.io/upload_images/291600-d8d4aa9865cbe04d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="源义经"></p><p>相比于前者，《万国觉醒》首充送的源义经，就显得良心了许多（仅针对首充而言），原因有二：</p><p>一、此英雄只能付费得到</p><p>“仅付费可得”在很多游戏里都可以见到，但是首充6元送的确实不多见。笔者曾经玩过《我叫MT online》，第五张紫卡小新（五张紫卡合成一张橙卡）需要充60月卡获得，大大姐、暗夜精灵累充上千获得一张紫卡。而首充仅需6元就可以获得的付费限定卡简直是太划算了，对于平民玩家来说，也是向氪金转型的极大诱惑。</p><p>二、长期可用</p><p>在《万国觉醒》里，打野是核心玩法里很重要的一环，而源义经作为橙卡里最强的打野英雄（没有之一），相比其他游戏“6元首充，用完就扔”，《万国觉醒》的良心就不用多说了。</p><p>设想如果《率土之滨》里的6元首充，由“何太后”换成“吕蒙”，相信率土玩家们会像超市里的大妈一样冲向打折商品。但是率土不会这么做，也不敢这么做，因为赔本的买卖，率土不会去做。而《万国觉醒》之所以敢做“赔本的买卖”，是因为《万国觉醒》里面的所有橙卡培养的坑都很深，每隔十级，需要用橙色碎片来升星，每个英雄有5个技能，每个技能升等级需要相同英雄的碎片，而想要将源义经升级到满配，别想了，那个是土豪才有能力做的事。但是对于平民来说，我买个首充，开局和土豪们平起平坐，花个6块钱，买一份优越感总不亏，况且用不用源义经完全是两个世界的体验，一个字——“买”。花了钱，玩家就开始珍视这个账号了，因为扔掉可惜，继续玩吧！有了第一笔消费，后面再搞几个大优惠活动，还愁玩家不掏钱吗？</p><p>综上所述，<strong>首充是一个放长线钓大鱼的绝佳时机</strong>，赋予首充长远的“价值”，让首充更加诱人。</p><h1 id="大神玩核心，小白玩养成"><a href="#大神玩核心，小白玩养成" class="headerlink" title="大神玩核心，小白玩养成"></a>大神玩核心，小白玩养成</h1><p>从高中开始，笔者开始接触《穿越火线》端游，到现在大学毕业已经三年了，笔者依然偶尔会在双休日上去玩两把。差不多十年了！枪法应该超神了吧？！不不不，笔者的水平依然停留在运输船出门被爆头、爆破模式不敢玩、个人战垫底、挑战模式只玩巨人城的水平。那么这十年，笔者到底玩了什么呢？emmmm…  2.0版本之前，笔者玩的是超越自我（破下限记录）；而2.0以后，笔者有了更高的目标，就是尽可能地屯活动送的免费永久武器。每当有活动时，笔者就会登录上去，玩一局团队竞技超越一下自我，然后去领活动送的武器，不管是永久还是限时，拿到后先去体验一把。嗯~果然好枪，一看战绩——15/35，下线！</p><p>而到了毕业后，开始玩《率土之滨》，笔者总是能很和谐地处理与周边邻居的关系：<br>“兄弟，我要塞边上的五级地可不可以给我留一块，等我有能力打了可以扫荡练级。”<br>“大佬，可以帮我打一下主城边上的四级地吗？谢谢了！”<br>而当其他大佬已经开始上战场时，笔者还在练自己的20级部队。时间久了，笔者也开始慢慢地适应了。其他玩家玩的是心跳，打的是T0强队；而笔者玩的是佛系，抽的是40抽保底。看着图鉴里的灰色卡面一个一个变彩色，心里感到了满足。嗯，真的T_T</p><p>上文有提到过，笔者不是玩游戏的料，所有与<strong>手速</strong>、<strong>精准度</strong>、<strong>策略</strong>相关的游戏（简言之：需要手、眼、脑并用的游戏），只要是笔者涉略的，不用想，肯定被玩成了养成类游戏。一个游戏，或多或少，都会有养成和竞争的元素，佛系、有耐心地小白玩家尚可在喜欢的竞争游戏的夹缝中找寻属于自己的小天地，但若是耐心被消磨、佛系不再了，弃坑也就随之而来。所以一个游戏若想受众面广，需要考虑游戏的多方向性，硬核玩家</p><h1 id="长线游戏，如何让划水玩家不掉队？"><a href="#长线游戏，如何让划水玩家不掉队？" class="headerlink" title="长线游戏，如何让划水玩家不掉队？"></a>长线游戏，如何让划水玩家不掉队？</h1><ul><li>闪念于2019年12月底某个去吃午饭的路上</li></ul>]]></content:encoded>
      
      <comments>http://wjnovember.github.io/game_thinking/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RichText打字机效果实现思路分享</title>
      <link>http://wjnovember.github.io/richtext_getallletters/</link>
      <guid>http://wjnovember.github.io/richtext_getallletters/</guid>
      <pubDate>Thu, 17 Oct 2019 12:18:53 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h1&gt;&lt;p&gt;今天在开发游戏引导框架时，遇到这样的需求：人物对话文本支持&lt;strong&gt;打字机效果&lt;/strong&gt;，且需要&lt;strong
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>今天在开发游戏引导框架时，遇到这样的需求：人物对话文本支持<strong>打字机效果</strong>，且需要<strong>个别文字高亮</strong>。如果仅仅是前者的需求，是挺好实现的，创建一个<code>Label</code>，通过<code>getLetter(index)</code>获取每个字，调用<code>setVisible(isVisible)</code>即可；但是个别文字高亮是RichText才有的功能，于是难点变成了<strong>如何获取RichText里的每个字</strong>？</p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>话不多说，看源代码，从<code>UIRichText.cpp</code>文件的<code>formatText</code>方法中，我们发现<code>RichText</code>的本质就是多个<code>Label</code>的拼接：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RichText::formatText(<span class="keyword">bool</span> isForce)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">        _elementRenders.clear();</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">ssize_t</span> i=<span class="number">0</span>; i&lt;_richElements.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                RichElement* element = _richElements.at(i);</span><br><span class="line">                Node* elementRenderer = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">switch</span> (element-&gt;_type)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> RichElement::Type::TEXT:</span><br><span class="line">                    &#123;</span><br><span class="line">                        RichElementText* elmtText = <span class="keyword">static_cast</span>&lt;RichElementText*&gt;(element);</span><br><span class="line">                        Label* label;</span><br><span class="line">                        <span class="keyword">if</span> (FileUtils::getInstance()-&gt;isFileExist(elmtText-&gt;_fontName))</span><br><span class="line">                        &#123;</span><br><span class="line">                             label = Label::createWithTTF(elmtText-&gt;_text, elmtText-&gt;_fontName, elmtText-&gt;_fontSize);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            label = Label::createWithSystemFont(elmtText-&gt;_text, elmtText-&gt;_fontName, elmtText-&gt;_fontSize);</span><br><span class="line">                        &#125;</span><br><span class="line">                        ...</span><br><span class="line">                        elementRenderer = label;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> RichElement::Type::IMAGE:</span><br><span class="line">                    &#123;</span><br><span class="line">                      ...</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> RichElement::Type::CUSTOM:</span><br><span class="line">                    &#123;</span><br><span class="line">                      ...</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> RichElement::Type::NEWLINE:</span><br><span class="line">                    &#123;</span><br><span class="line">                      ...</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (elementRenderer)</span><br><span class="line">                &#123;</span><br><span class="line">                    Label * pLabel = <span class="keyword">dynamic_cast</span>&lt;Label *&gt;(elementRenderer);</span><br><span class="line">                    <span class="keyword">if</span> (pLabel)</span><br><span class="line">                    &#123;</span><br><span class="line">                        pLabel-&gt;setTextColor(Color4B(element-&gt;_color, element-&gt;_opacity));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        elementRenderer-&gt;setColor(element-&gt;_color);</span><br><span class="line">                        elementRenderer-&gt;setOpacity(element-&gt;_opacity);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    pushToContainer(elementRenderer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 与前一段if结构基本一致</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">        formarRenderers();</span><br><span class="line">        _formatTextDirty = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑是通过读取<code>insertElement()</code>方法传入的<code>RichElement</code>，根据RichElement类别的不同，创建<code>Label</code>、<code>Sprite</code>、<code>Node</code>等，放入RichText这个容器中，因为在当前情境下，只有<code>Label</code>被创建，所以其他不在考虑范围。</p><p>有了<code>Label</code>就可以拿到每个文字了，那么<code>Label</code>从哪里获取呢？我们把上面代码再精简下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RichText::formatText(<span class="keyword">bool</span> isForce)</span><br><span class="line">&#123;</span><br><span class="line">    _elementRenders.clear();</span><br><span class="line">    Node* elementRender = Label::create...</span><br><span class="line">    pushToContainer(elementRender);</span><br><span class="line">    formarRenderers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现<code>Label</code>被传进了<code>pushToContainer(render)</code>方法中，这个方法的代码很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RichText::pushToContainer(cocos2d::Node *renderer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_elementRenders.size() &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _elementRenders[_elementRenders.size()<span class="number">-1</span>]-&gt;pushBack(renderer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以思路就变成了<strong>如何从<code>_elementRenders</code>中获取所有的<code>Label</code></strong>？</p><h1 id="逻辑编写"><a href="#逻辑编写" class="headerlink" title="逻辑编写"></a>逻辑编写</h1><p>基于上述梳理，编写获取<code>RichText</code>中所有文字的逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RichText::getAllLetters()</span><br><span class="line">&#123;</span><br><span class="line">    Vector&lt;Sprite*&gt; letters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : _elementRenders)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector&lt;Node*&gt;* row = element;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">ssize_t</span> i = <span class="number">0</span>; i&lt;row-&gt;size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* pNode = row-&gt;at(i);</span><br><span class="line">            Label * pLabel = <span class="keyword">dynamic_cast</span>&lt;Label*&gt;(pNode);</span><br><span class="line">            <span class="keyword">if</span> (pLabel)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> len = pLabel-&gt;getStringLength();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Sprite* letter = pLabel-&gt;getLetter(j);</span><br><span class="line">                    <span class="keyword">if</span> (letter)</span><br><span class="line">                        letters.pushBack(letter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> letters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写完成，将<code>CPP</code>转为<code>Lua</code>，看一下效果！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码：</span><br><span class="line">local ret = richText:getAllLetters()</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">ret: &#123;&#125;</span><br></pre></td></tr></table></figure><p>为什么会出现这样的情况呢？</p><p>打断点，进入<code>getAllLetters()</code>，傻眼了，<code>_elementRenders</code>是个空数组。原因是<code>formatText()</code>方法的最后，RichText调用了<code>formarRenderers()</code>方法，我们来简单地看一下<code>formarRenderers</code>的逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RichText::formarRenderers()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此处省略一大坨代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> length = _elementRenders.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">  &#123;</span><br><span class="line">        Vector&lt;Node*&gt;* l = _elementRenders[i];</span><br><span class="line">        l-&gt;clear();</span><br><span class="line">        <span class="keyword">delete</span> l;</span><br><span class="line">  &#125;    </span><br><span class="line">    _elementRenders.clear();</span><br><span class="line">    </span><br><span class="line">    updateContentSizeWithTextureSize(_contentSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面做了什么逻辑我们不关心，我们关心的是方法的最后调用了<code>_elementRenders.clear()</code>，也就是说：每次执行<code>formatText()</code>后，<code>_elementRenders</code>都会被清空，它只是一个临时变量，所以接下来要做的就是<strong>在<code>_elementRenders</code>被清掉前，遍历获取每一个Letter并存下来</strong>。</p><p>于是代码变成了这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">UIRichText.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC_GUI_DLL</span> <span class="title">RichText</span> :</span> <span class="keyword">public</span> Widget</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector&lt;Sprite*&gt;&amp; getAllLetters();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Vector&lt;Sprite*&gt; _letters;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">UIRichText.CPP</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RichText::updateLetters()</span><br><span class="line">&#123;</span><br><span class="line">    _letters.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : _elementRenders)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector&lt;Node*&gt;* row = element;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">ssize_t</span> i = <span class="number">0</span>; i&lt;row-&gt;size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* pNode = row-&gt;at(i);</span><br><span class="line">            Label * pLabel = <span class="keyword">dynamic_cast</span>&lt;Label*&gt;(pNode);</span><br><span class="line">            <span class="keyword">if</span> (pLabel)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> len = pLabel-&gt;getStringLength();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Sprite* letter = pLabel-&gt;getLetter(j);</span><br><span class="line">                    <span class="keyword">if</span> (letter)</span><br><span class="line">                        _letters.pushBack(letter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector&lt;Sprite*&gt;&amp; RichText::getAllLetters()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _letters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RichText::formarRenderers()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此处省略一大坨代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------</span></span><br><span class="line">    <span class="comment">// 添加的代码</span></span><br><span class="line">    updateLetters();</span><br><span class="line">    <span class="comment">// ------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> length = _elementRenders.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">  &#123;</span><br><span class="line">        Vector&lt;Node*&gt;* l = _elementRenders[i];</span><br><span class="line">        l-&gt;clear();</span><br><span class="line">        <span class="keyword">delete</span> l;</span><br><span class="line">  &#125;    </span><br><span class="line">    _elementRenders.clear();</span><br><span class="line">    </span><br><span class="line">    updateContentSizeWithTextureSize(_contentSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于，CPP层间的逻辑算是实现了。但这时候，又有新的问题出现了。</p><h1 id="解决LabelLetter无法转Lua问题"><a href="#解决LabelLetter无法转Lua问题" class="headerlink" title="解决LabelLetter无法转Lua问题"></a>解决LabelLetter无法转Lua问题</h1><p>按照新的逻辑，从Lua层面调用<code>getAllLetters()</code>方法，发现获取的结果依然是空table；但是在CPP层面，却是可以获取到数据的。那么问题就出在<code>toLua</code>的过程。</p><blockquote><p><strong>说明</strong>：tolua是cocos2d-x提供的lua-binding工具，位于项目tools/tolua目录下。</p></blockquote><p>继续断点调试，将问题定位在了下面这个方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a table converted from a cocos2d::Vector object into the Lua stack.</span></span><br><span class="line"><span class="comment"> * The format of table as follows: &#123;userdata1, userdata2, ..., userdataVectorSize&#125;</span></span><br><span class="line"><span class="comment"> * The object in the cocos2d::Vector which would be pushed into the table should be Ref type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L the current lua_State.</span></span><br><span class="line"><span class="comment"> * @param inValue a cocos2d::Vector object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ccvector_to_luaval</span>(<span class="title">lua_State</span>* <span class="title">L</span>,<span class="title">const</span> <span class="title">cocos2d</span>:</span>:Vector&lt;T&gt;&amp; inValue)</span><br><span class="line">&#123;</span><br><span class="line">    lua_newtable(L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == L)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> indexTable = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; obj : inValue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == obj)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> != <span class="keyword">dynamic_cast</span>&lt;cocos2d::Ref *&gt;(obj))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> typeName = <span class="keyword">typeid</span>(*obj).name();</span><br><span class="line">            <span class="keyword">auto</span> iter = g_luaType.find(typeName);</span><br><span class="line">            <span class="keyword">if</span> (g_luaType.end() != iter)</span><br><span class="line">            &#123;</span><br><span class="line">                lua_pushnumber(L, (lua_Number)indexTable);</span><br><span class="line">                <span class="keyword">int</span> ID = (obj) ? (<span class="keyword">int</span>)obj-&gt;_ID : <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span>* luaID = (obj) ? &amp;obj-&gt;_luaID : <span class="literal">NULL</span>;</span><br><span class="line">                toluafix_pushusertype_ccobject(L, ID, luaID, (<span class="keyword">void</span>*)obj,iter-&gt;second.c_str());</span><br><span class="line">                lua_rawset(L, <span class="number">-3</span>);</span><br><span class="line">                ++indexTable;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题的症结出在了<code>g_luaType</code>这里，在这个数组里，找不到<code>LabelLetter</code>类，虽然<code>getAllLetters()</code>返回的是<code>Sprite</code>的数组，但本质上，<code>Label::getLetter()</code>中返回的Sprite是通过<code>LabelLetter</code>创建的，而<code>LabelLetter</code>是在<code>CCLabel.cpp</code>里面定义的，<code>g_luaType</code>根本不知道<code>LabelLetter</code>的存在。</p><p>既然如此，就一改到底吧！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ccvector_to_luaval</span>(<span class="title">lua_State</span>* <span class="title">L</span>,<span class="title">const</span> <span class="title">cocos2d</span>:</span>:Vector&lt;T&gt;&amp; inValue)</span><br><span class="line">&#123;</span><br><span class="line">    lua_newtable(L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == L)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> indexTable = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; obj : inValue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == obj)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> != <span class="keyword">dynamic_cast</span>&lt;cocos2d::Ref *&gt;(obj))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> typeName = <span class="keyword">typeid</span>(*obj).name();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// --------------------------------------------</span></span><br><span class="line">            <span class="comment">// 添加的代码</span></span><br><span class="line">            <span class="keyword">if</span> (typeName == <span class="string">"class cocos2d::LabelLetter"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                typeName = <span class="string">"class cocos2d::Sprite"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --------------------------------------------</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> iter = g_luaType.find(typeName);</span><br><span class="line">            <span class="keyword">if</span> (g_luaType.end() != iter)</span><br><span class="line">            &#123;</span><br><span class="line">                lua_pushnumber(L, (lua_Number)indexTable);</span><br><span class="line">                <span class="keyword">int</span> ID = (obj) ? (<span class="keyword">int</span>)obj-&gt;_ID : <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span>* luaID = (obj) ? &amp;obj-&gt;_luaID : <span class="literal">NULL</span>;</span><br><span class="line">                toluafix_pushusertype_ccobject(L, ID, luaID, (<span class="keyword">void</span>*)obj,iter-&gt;second.c_str());</span><br><span class="line">                lua_rawset(L, <span class="number">-3</span>);</span><br><span class="line">                ++indexTable;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取typeName以后，判断typeName的类别，若是<code>class cocos2d::LabelLetter</code>，则将其强行改为<code>class cocos2d::Sprite</code>。</p><p>至此，RichText可算可以调用<code>getAllLetters()</code>拿到所有的文字了，本教程也算告一段落。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>本文的逻辑重在实现思路，其实其中也存在很多待优化的地方，如：富文本存在表情图片时如何支持打字机效果？又如：后面转Lua裸写类别名的判断不够优雅。还有诸如：不需要打字机效果的文本存_letters会造成内存浪费等。感兴趣的读者欢迎在本文的基础上进行优化修改！感谢阅读~</p>]]></content:encoded>
      
      <comments>http://wjnovember.github.io/richtext_getallletters/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
