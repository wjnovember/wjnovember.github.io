---
title: 《Unity Shader入门精要》笔记（三）
categories:
  - TA不是他她它祂
date: 2021-11-20 16:02:57
tags:
  - Unity Shader
---

> 本文记录《第4章 学习Shader所需的数学基础》的矩阵基础知识内容。

# 笛卡尔坐标系

## 二维笛卡尔坐标系

![](img_01.png)

二维笛卡尔坐标系：
* 原点
* x轴、y轴（基矢量）

x轴、y轴朝向并非固定，如：OpenGL和DirectX使用了不同的二维笛卡尔坐标系。

![](img_02.png)

## 三维笛卡尔坐标系

![](img_03.png)

三维笛卡尔坐标系：
* 原点
* x轴、y轴、z轴（基矢量）

标准基矢量：互相垂直，且长度为1的基矢量。
正交基：互相垂直，但长度不为1的基矢量。

## 左手坐标系和右手坐标系

以手的大拇指作为`+x`轴，食指作为`+y`轴，中指作为`+z`轴，将3根手指互相垂直，可以用左手示意的坐标系，为左手坐标系：

![](img_04.png)

可以用右手示意的坐标系，为右手坐标系：

![](img_05.png)

左手坐标系和右手坐标系无法通过旋转实现坐标轴指向重合。

左手坐标系和右手坐标系分别对应**左手法则**和**右手法则**，用来在坐标系中定义旋转的正方向，下图4个手指指向的方向即为正方向：

![](img_06.png)

## Unity使用的坐标系

Unity的模型空间和世界空间使用的是左手坐标系，注意观看下图红、绿、蓝轴在右上角分别对应x轴、y轴、z轴：

![](img_07.png)

Unity的观察空间使用的是右手坐标系。观察空间，就是以摄像机作为原点的坐标系，在这个坐标系中，摄像机的前向是z轴的负方向，与模型/世界空间的定义相反。即：z轴坐标的减少意味着场景深度的增加。

![](img_08.png)

# 点和矢量

点是n维空间（游戏中主要是用二维、三维空间）中的一个位置，没有大小、宽度的概念。
二维空间点的表示：`p = (x, y)`
三维空间点的表示：`p = (x, y, z)`

矢量是n为空间中包含模和方向的有向线段，没有位置的概念。
矢量的模：矢量的长度，非负数。
矢量的方向：矢量在空间中的指向。
矢量的表示与点类似，`v = (x, y)，v = (x, y, z)，v = (x, y, z, w)`。

为区分点和矢量，在变量书写上，标量用小写字母表示，如：a, b, x, y, z等；矢量用小写的粗体字母表示，如：**a**, **b**, **u**, **v**等。

矢量通常有一个箭头表示：

![](img_09.png)

## 矢量和标量的乘法/除法

标量是只有模，没有方向的量，比如：距离、速度等。
矢量无法与标量进行加减运算，但是可以进行乘法或除法运算。

矢量与标量的乘法：
`kv = (kvx, kvy, kvz)`

矢量可以被非0的标量除，但是矢量无法作为除数：

![](img_10.png)

从几何意义上看，一个矢量**v**和一个标量k相乘，意味着对矢量**v**进行一个大小为|k|的缩放。若k<0，则矢量方向取反，如下图：

![](img_11.png)

## 矢量的加法和减法

两个矢量加减，即：两个矢量的对应分量进行加减，公式如下：
**a** + **b** = (a<sub>x</sub>+b<sub>x</sub>, a<sub>y</sub>+b<sub>y</sub>, a<sub>z</sub>+b<sub>z</sub>)
**a** - **b** = (a<sub>x</sub>-b<sub>x</sub>, a<sub>y</sub>-b<sub>y</sub>, a<sub>z</sub>-b<sub>z</sub>)

从几何意义上看，矢量加法，即：把矢量**a**的头连接到矢量**b**的尾，然后画一条从**a**的尾到**b**的头的矢量，来得到**a**和**b**相加后的矢量，如下图所示：

![](img_12.png)

也可以理解为：一个点从**a**的尾进行位置偏移**a**，在进行位置偏移**b**，就等同于进行了**a**+**b**的位置偏移，这被称为矢量加法的**三角形定则**。

矢量的减法类似：

![](img_13.png)

在图形学中，矢量通常用于描述位置偏移（简称位移）。我们可以利用矢量的加法和减法来计算一点相对于另一点的位移。

## 矢量的模

矢量的模是一个标量，可以理解为矢量在空间中的长度。表示符号通常是在矢量的两边加上竖线，比如：|**v**|。

三维矢量的模的计算公式：

![](img_14.png)

其他维度的矢量的模计算类似，都是对每个分量平方相加后开根号。几何意义，可用下图解释：

![](img_15.png)

## 单位矢量

单位矢量指模为1的矢量，也被称为被归一化的矢量（normalized vector）。通常用在只关心方向，不关心模的矢量，比如：模型的发现方向、光源方向等。

把非零矢量转换成单位矢量的过程叫**归一化**。
单位矢量的表示为：

![](img_16.png)

单位矢量的公式：

![](img_17.png)

零矢量：每个分量的值都为0的矢量，如：**v** = (0, 0, 0)。零矢量不能被归一化，因为除法运算时，分母不能为0。

从几何意义上看，对于二维空间，单位矢量就是从圆心出发、到圆边界的矢量：

![](img_18.png)

对于三维空间，单位矢量就是从圆心出发、到球面的矢量。

在Unity Shader中，会经常遇到法线方向、光源方向，这些矢量不一定是归一化后的矢量，计算的时候需要将这些矢量归一化成单位矢量。

## 矢量的点积

矢量的乘法有两种类型：点积（dot product）、叉积（cross product）。

矢量的点积，也叫内积。点积的运算表示：**a**·**b**，中间的点不能省略。

**点积公式一**：
**a**·**b** = (ax, ay, az) · (bx, by, by) = axby + ayby + azbz

点积满足交换律：
**a**·**b** = **b**·**a**

点积的几何意义：**投影**。

![](img_18.png)

投影的值可能是负数，投影结果的正负号与**a**、**b**两个矢量的方向有关：方向相反，结果小于0；方向相同，结果大于0；方向垂直，结果等于0。

性质一：
点积可结合标量乘法
(k**a**)·**b** = **a**·(k**b**)=k(**a**·**b**)
k的几何意义是：对矢量进行缩放。

性质二：
点积可结合矢量加减法
**a**·(**b**+**c**) = **a**·**b** + **a**·**c**
将**c**换成-**c**就是减法的版本。

性质三：
一个矢量与自身点积的结果是该矢量模的平方
**v**·**v** = v<sub>x</sub>v<sub>x</sub> + v<sub>y</sub>v<sub>y</sub> + v<sub>z</sub>v<sub>z</sub> = |**v**|<sup>2</sup>
可以用矢量点积的形式来求矢量的模，Shader中常用模的平方来直接做比较或运算，目的是减少开放带来的性能消耗。

**点积公式二**：
**a**·**b** = |**a**||**b**|cosθ

公式二的证明：
假设对两个单位矢量进行点积

![](img_20.png)

如下图所示：

![](img_21.png)

由上图可知，cosθ对应的直角边是：**a**·**b**的点积（**b**矢量在**a**矢量的投影），且`cosθ = 直角边 / 斜边`，则**a**·**b**的点积 = `cosθ * 斜边`，因为单位矢量**b**的模是1（斜边长度为1），所以：**a**·**b**的点积 = cosθ，也就是两个单位矢量的点积为夹角的cos值。

再由之前性质一，可得推导公式二：

![](img_23.png)

由公式二可知，点积可用于求两个矢量的夹角：

![](img_22.png)

## 矢量的叉积

叉积，也叫外积。与点积不同，叉积的结果仍然是矢量，而非标量。

叉积的表示：**a** x **b**，叉号不能省略。叉积的计算公式如下：
**a** x **b** = (a<sub>x</sub>, a<sub>y</sub>, a<sub>z</sub>) x (b<sub>x</sub>, b<sub>y</sub>, b<sub>z</sub>) = (a<sub>y</sub>b<sub>z</sub>-a<sub>z</sub>b<sub>y</sub>, a<sub>z</sub>b<sub>x</sub>-a<sub>x</sub>b<sub>z</sub>, a<sub>x</sub>b<sub>y</sub>-a<sub>y</sub>b<sub>x</sub>)

具体的记法，可以这样：
1. 先看每个分量的被减数
a<sub>y</sub>b<sub>z</sub>、a<sub>z</sub>b<sub>x</sub>、a<sub>x</sub>b<sub>y</sub>，它们下标的规律是不包含当前分量下标，比如：x分量的被减数只有y、z下标，y分量的被减数只有x、z下标，z分量的被减数只有x、y下标。
2. 然后看被减数中a的下标
a<sub>y</sub>、a<sub>z</sub>、a<sub>x</sub>，a的下标永远是当前分量的下一个，比如：x分量的下标是y，y分量的下标是z，z分量的下标是x。
3. 再看被减数中b的下标
b<sub>z</sub>、b<sub>x</sub>、b<sub>y</sub>，b的下标永远和a不一样，再结合第1点记忆，b的下标不是当前分量，所以x分量b的下标只能是除了x以外的y、z的其中一个，而y被a用了，所以b的下标只能是z，其他分量的b以此类推。
4. 再看每个分量的减数
a<sub>z</sub>b<sub>y</sub>、a<sub>x</sub>b<sub>z</sub>、a<sub>y</sub>b<sub>x</sub>，他们的下标就是被减数中a和b下标的互换，所以aybz的减数是azby，其他以此类推。

叉积不满足交换律，即：**a** x **b** ≠ **b** x **a**；但是叉积满足反交换律，即：**a** x **b** = - (**b** x **a**)。
叉积不满足结合律，即：(**a** x **b**) x **c** ≠ **a** x (**b** x **c**)。

叉积的几何意义：
对两个矢量进行叉积的结果，会得到同时垂直于这两个矢量的新矢量。

**叉积的模**
公式：
|**a** x **b**| = |**a**||**b**|sinθ

这容易联想到平行四边形求面积：

![](img_24.png)

面积A = |**b**| h = |**b**| (|**a**| sinθ) = |**a**||**b**|sinθ

**叉积的方向**
从几何意义可知，两个矢量的叉积，会得到垂直于两个矢量的新矢量，但是与其垂直的有两个向量。这时前面学到的**左/右手坐标系**就派上用场了，它用来确定叉积得到新矢量的方向朝哪边。

将大拇指与a同向，食指与b同向，中指指向的方向就是叉积结果的方向，所以使用左、右手就会得到不同的朝向，如下图：

![](img_25.png)

同理，左右手法则也通用可以用来判断，如下图：

![](img_26.png)

# 矩阵

## 矩阵的定义

矩阵（Matrix），就是有m x n个标量组成的长方形数组，通常用方括号在左右两侧围住这些数字，大概像这样：

![](img_27.png)

有些资料也会用圆括号或花括号，其实都一样的。

矩阵有行、列之分，上图的数组就是三行四列。以3x3矩阵为例，它可以写成：

![](img_28.png)

mij表示这个元素在矩阵M的第i行、第j列。

## 和矢量联系起来

矢量，我们通常写成：**a** = (x, y, z)，可以看出矢量与矩阵一样，也是个数组。将矢量按照矩阵的写法，可以看成是`n x 1`的列矩阵或`1 x n`的行矩阵，n对应矢量的维度。

以矢量**v** = (3, 8, 6)举例，写成行矩阵：
`[3, 8, 6]`

写成列矩阵：

![](img_29.png)

为什么要和矢量联系起来？因为Shader中经常会将法线（矢量）进行坐标变换，而坐标变换是矩阵的几何意义，所以需要运用矩阵的运算来将法线从模型空间转变成世界空间。（后续会学到）

## 矩阵运算

### 矩阵和标量的乘法

与矢量类似，矩阵和标量相乘后，结果仍然是一个矩阵。公式如下：

![](img_30.png)

### 矩阵和矩阵的乘法

矩阵和矩阵相乘后，结果也是矩阵。新的矩阵的维度与两个原矩阵的维度有关。一个`rxn`的矩阵A和一个`nxc`的矩阵B相乘后，得到的结果AB是一个`rxc`大小的矩阵。需要注意，**第一个矩阵的列数必须和第二个矩阵的行数相等，才能相乘**。

比如：矩阵A的维度是`4x3`，矩阵B的维度是`3x6`，则AB的维度是`4x6`。

矩阵乘法的表达式：
假设有`rxn`的矩阵A和`nxc`的矩阵B，相乘后得到一个`rxc`的矩阵C = AB，那么C中的每个元素Cij等于A的第i行所对应的矢量和B的第j列所对应的矢量进行点乘的结果，即：

![](img_31.png)

简单解释为：
对于每个元素c<sub>ij</sub>，找到A中的第`i`行和B中的第`j`列，把他们对应的元素相乘后再加起来，这个和就是c<sub>ij</sub>。

![](img_32.png)

性质一：
矩阵乘法不满足交换律：`AB ≠ BA`

性质二：
矩阵乘法满足结合律：`(AB)C = A(BC)`、`ABCDE = ((A(BC))D)E = (AB)(CD)E`

### 特殊的矩阵
#### 方块矩阵
方块矩阵，简称方阵。指行数和列数相等的矩阵，比如：`3x3`、`4x4`的矩阵。

方块矩阵独有的：**对角元素**——行号和列号相等的元素。只有对角元素非0的矩阵叫**对角矩阵**。

#### 单位矩阵

对角元素都为1的对角矩阵，叫做单位矩阵，用I<sub>n</sub>表示，比如：

![](img_33.png)

单位矩阵特性：任何矩阵和它相乘的结果还是原来的矩阵。相当于标量中1的地位。
`MI = IM = M`

#### 转置矩阵

转置矩阵实际是对原矩阵的一种运算，即转置运算。一个`rxc`的矩阵M，其转置表示成M<sup>T</sup>，是一个`cxr`的矩阵，本质是原来的矩阵行、列对换。

![](img_34.png)

性质一：
矩阵转置的转置等于原矩阵。
(M<sup>T</sup>)<sup>T</sup> = M

性质二：
矩阵串联的转置，等于反向串联各个矩阵的转置。
(AB)<sup>T</sup> = B<sup>T</sup>A<sup>T</sup>

#### 逆矩阵

只有方阵才有逆矩阵，逆矩阵表示为M<sup>-1</sup>。一个矩阵与它的逆矩阵相乘，结果是一个单位矩阵：
MM<sup>-1</sup> = M<sup>-1</sup>M = I
有点标量里面倒数的味道。

不是所有方阵都有对应逆矩阵，比如：所有元素都为0的矩阵。
如果一个矩阵有对应的逆矩阵，则它是**可逆的**或**非奇异性的**；
相反，则它是**不可逆的**或**奇异性的**。

判断矩阵是否可逆：
矩阵的**行列式**不为0，则它是可逆的。
参考视频链接：https://www.bilibili.com/video/BV1aW411Q7x1?p=2

性质一：
逆矩阵的逆矩阵是原矩阵本身。
(M<sup>-1</sup>)<sup>-1</sup> = M

性质二：
单位矩阵的逆矩阵是它本身。
I<sup>-1</sup> = I

性质三：
转置矩阵的逆矩阵是逆矩阵的转置。
(M<sup>T</sup>)<sup>-1</sup> = (M<sup>-1</sup>)<sup>T</sup>

性质四：
矩阵串联相乘后的逆矩阵等于反串联各个矩阵的逆矩阵。
(AB)<sup>-1</sup> = B<sup>-1</sup>A<sup>-1</sup>
(ABCD)<sup>-1</sup> = D<sup>-1</sup>C<sup>-1</sup>B<sup>-1</sup>A<sup>-1</sup>

矩阵的几何意义是**变换**，逆矩阵表示还原这个变换，或这个变换的反向变换。
使用变化矩阵M对矢量**v**进行一次变换，然后再使用逆矩阵M<sup>-1</sup>进行一次变换，会得到原来的矢量v。
M<sup>-1</sup>(M**v**) = (M<sup>-1</sup>M)**v** = I**v** = **v**

#### 正交矩阵

正交矩阵是特殊的方阵。一个方阵M和它的转置矩阵的乘积是单位矩阵，则这个矩阵是正交的。
MM<sup>T</sup> = M<sup>T</sup>M = I

有逆矩阵的性质MM<sup>-1</sup> = M<sup>-1</sup>M = I可以得出正交矩阵的逆矩阵是它的转置矩阵：
M<sup>T</sup> = M<sup>-1</sup>

正交矩阵可以用转置矩阵的运算代替逆矩阵的运算，因为逆矩阵计算更复杂。

怎样判定一个矩阵是正交矩阵？来看一下它有哪些定义。

因为：

![](img_35.png)

所以：

![](img_36.png)

于是可以得到以下结论：
* 矩阵的每一行，即c<sub>1</sub>、c<sub>2</sub>、c<sub>3</sub>是单位矢量；（因为他们与自己的点积是1）
* 矩阵的每一行，即c<sub>1</sub>、c<sub>2</sub>、c<sub>3</sub>之间相互垂直；（因为他们的点积是0）
* 上述两条，对矩阵的每一列同样适用；（因为正交矩阵的转置通用是正交矩阵）

### 行矩阵还是列矩阵

一个矢量（比如：平行光的方向、表面发现方向），既可以写成行矩阵的形式，也可以写成列矩阵的形式，但是当它和矩阵相乘时，使用行矩阵还是列矩阵对其乘法的书写次序和结果值是有影响的。

假设有一个矢量**v** = (x, y, z)，写成行矩阵是：**v** = [x y z]，写成列矩阵是：**v** = [x y z]<sup>T</sup>（这里使用转置符号表示列矩阵的写法，纯粹为了排版）。另外有一个矩阵M：

![](img_37.png)

当M和行矩阵相乘时，写法为：
**v**M = [xm<sub>11</sub>+ym<sub>21</sub>+zm<sub>31</sub>   xm<sub>12</sub>+ym<sub>22</sub>+zm<sub>32</sub>   xm<sub>13</sub>+ym<sub>23</sub>+zm<sub>33</sub>]

当M和列矩阵相乘时，写法为：

![](img_38.png)

可以看到两者相乘的书写次序和结果里面元素也是不一样的。

Unity中通常把矢量当做列矩阵，所以相乘时，矢量是放在矩阵的右侧的，且阅读顺序也是从右到左。例如：
CBA**v** = (C(B(A**v**)))
表示先对**v**进行A矩阵变换，再进行B矩阵变换，最后进行C矩阵变换。